package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
	"sync"
	"text/template"

	"pkg.jsn.cam/caddy-defender/ranges/data"
	"pkg.jsn.cam/caddy-defender/ranges/fetchers"
	"pkg.jsn.cam/caddy-defender/ranges/fetchers/aws"
)

var (
	outputFormat string
	outputFile   string
	asnList      string
	fetchTor     bool
)

func main() {
	// Define flags
	flag.StringVar(&outputFormat, "format", "go", "Output format: json or go")
	flag.StringVar(&outputFile, "output", "ranges/data/generated.go", "Output file path")
	flag.StringVar(&asnList, "asn", "", "Comma-separated list of ASNs to fetch (e.g., AS15169,AS32934)")
	flag.BoolVar(&fetchTor, "fetch-tor", false, "Enable fetching of Tor exit nodes")
	flag.Parse()

	// Create an array of all IP range fetchers
	fetchersList := []fetchers.IPRangeFetcher{
		fetchers.VPNFetcher{},                  // Known VPN services
		fetchers.LinodeFetcher{},               // Linode
		fetchers.DigitalOceanFetcher{},         // Digital Ocean
		fetchers.OpenAIFetcher{},               // OpenAI services
		fetchers.DeepSeekFetcher{},             // DeepSeek
		fetchers.OracleFetcher{},               // Oracle Cloud
		fetchers.GithubCopilotFetcher{},        // GitHub Copilot
		fetchers.AzurePublicCloudFetcher{},     // Azure Public Cloud
		fetchers.GCloudFetcher{},               // Google Cloud Platform
		aws.AWSFetcher{},                       // Global AWS IP ranges
		aws.RegionFetcher{Region: "us-east-1"}, // us-east-1 region
		aws.RegionFetcher{Region: "us-west-1"}, // us-west-1 region
		// aws.RegionFetcher{Region: "eu-west-1"}, // eu-west-1 region
		fetchers.PrivateFetcher{},     // Private IP ranges (RFC 1918)
		fetchers.AllFetcher{},         // All IP ranges
		fetchers.MistralFetcher{},     // Mistral IP ranges
		fetchers.VultrFetcher{},       // Vultr Cloud IP ranges
		fetchers.CloudflareFetcher{},  // Cloudflare IP ranges
		fetchers.AliyunFetcher{},      // Aliyun IP ranges
		fetchers.HuaweiCloudFetcher{}, // Huawei Cloud IP ranges
	}

	if fetchTor {
		// the issue with the tor fetcher is that TOR is a network of individual nodes,
		// so it's not possible to get a list of all IP ranges. The current solution
		// converts individual nodes to IP ranges.
		fetchersList = append(fetchersList, fetchers.TorFetcher{}) // Tor exit nodes
	}

	if asnList != "" {
		// ASN fetcher with common cloud providers and AI companies
		// example: fetchers.NewASNFetcher([]string{
		//	"AS13335", // Cloudflare
		//	"AS16509", // Amazon AWS
		//	"AS8075",  // Microsoft
		//	"AS15169", // Google
		//	"AS54113", // Fastly
		//	"AS19551", // Incapsula
		//	"AS14061", // DigitalOcean
		//	"AS63949", // Linode
		//	"AS14618", // Amazon
		// }),
		asns := strings.Split(asnList, ",")
		fetchersList = append(fetchersList, fetchers.NewASNFetcher(asns))
	}

	// Load the existing IP ranges from the data package
	ipRanges := data.IPRanges

	// Use a WaitGroup to wait for all fetchers to complete
	var wg sync.WaitGroup
	wg.Add(len(fetchersList))

	// Use a mutex to safely update the ipRanges map
	var mu sync.Mutex

	// Start fetching IP ranges concurrently
	for _, fetcher := range fetchersList {
		go func(f fetchers.IPRangeFetcher) {
			defer wg.Done()

			// Print the start of the fetching process
			fmt.Printf("üöÄ Starting %s: %s\n", f.Name(), f.Description())

			// Fetch the IP ranges
			ranges, err := f.FetchIPRanges()
			if err != nil {
				fmt.Printf("‚ùå Error fetching %s: %v\n", f.Name(), err)
				return
			}

			// Update the map with the fetched ranges
			mu.Lock()
			ipRanges[strings.ToLower(f.Name())] = ranges
			mu.Unlock()

			// Print the completion of the fetching process
			fmt.Printf("‚úÖ Completed %s: Fetched %d IP ranges\n", f.Name(), len(ranges))
		}(fetcher)
	}

	wg.Wait()

	// Handle output based on the format flag
	switch outputFormat {
	case "json":
		writeJSON(ipRanges, outputFile)
	case "go":
		outputFile = strings.Replace(outputFile, ".json", ".go", 1)
		writeGoFile(ipRanges, outputFile)
	default:
		log.Fatalf("Invalid output format: %s. Use 'json' or 'go'", outputFormat)
	}

	// calculate total number of IP ranges

	var totalRanges int
	for _, ranges := range ipRanges {
		totalRanges += len(ranges)
	}

	fmt.Printf("üéâ All %d IP ranges have been successfully written to %s\n", totalRanges, outputFile)
}

// writeJSON writes the IP ranges to a JSON file.
func writeJSON(ipRanges map[string][]string, outputFile string) {
	jsonData, err := json.MarshalIndent(ipRanges, "", "  ")
	if err != nil {
		log.Fatalf("Failed to marshal IP ranges to JSON: %v", err)
	}
	file, err := os.Create(outputFile)
	if err != nil {
		log.Fatalf("Failed to create file: %v", err)
	}
	defer file.Close()

	_, err = file.Write(jsonData)
	if err != nil {
		log.Panicf("Failed to write JSON to file: %v", err)
	}
}

// writeGoFile writes the IP ranges to a Go file.
func writeGoFile(ipRanges map[string][]string, outputFile string) {
	const goTemplate = `package data

// Code generated by pkg.jsn.cam/caddy-defender/blob/main/ranges/main.go; DO NOT EDIT.

var IPRanges = map[string][]string{
	{{- range $key, $values := . }}
	"{{ $key }}": { {{- range $index, $value := $values }}
		"{{ $value }}",{{- end }}
	},{{- end }}
}
`

	// Write the generated Go file
	file, err := os.Create(outputFile)
	if err != nil {
		log.Fatalf("Failed to create output file: %v", err)
	}
	defer func(file *os.File) {
		err := file.Close()
		if err != nil {
			log.Fatalf("Error closing file: %v", err)
		}
	}(file)

	t := template.Must(template.New("code").Parse(goTemplate))
	err = t.Execute(file, ipRanges)
	if err != nil {
		log.Panicf("Failed to execute template: %v", err)
	}
}
